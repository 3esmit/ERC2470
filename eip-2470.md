---
eip: 2470
title: Singleton Factory
author: Ricardo Guilherme Schmidt (@3esmit), Richard Meissner <@rmeissner>
discussions-to: https://ethereum-magicians.org/t/erc-2470-singleton-factory/3933
status: Draft
type: Standards Track
category: ERC
created: 15-01-2020
requires: 1014
---

## Simple Summary

Some DApps needs one, and only one, instance of an contract, which have the same address on any chain.

A permissionless factory for deploy of keyless deterministic contracts addresses based on its bytecode. 

## Abstract

Some contracts are designed to be Singletons which have the same address no matter what chain they are, which means that should exist one instance for all, such as [EIP-1820] and [EIP-2429]. These contracts are usually deployed using a method known as [Nick]'s method, so anyone can deploy those contracts on any chain and they have a deterministic address.
This standard proposes the creation of a CREATE2 factory using this method, so other projects requiring this feature can use this factory in any chain with the same setup, even in development chains.    

## Motivation

Code reuse, using the factory becomes easier to deploy singletons.

## Specification

### [ERC2470] Singleton Factory

> This is an exact copy of the code of the [ERC2470 factory smart contract].

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity 0.7.3;


/**
 * @title ERC-2470: Singleton Factory
 * @notice Exposes CREATE2 (EIP-1014) to deploy bytecode on deterministic addresses based on initialization code and salt.
 * @author Ricardo Guilherme Schmidt <ricardo3@status.im>
 * @author Richard Meissner <richard@gnosis.io>
 */
contract ERC2470 {

    /**
     * @notice Fallback forwards `msg.data` with salt `bytes32(0)` to `deploy(bytes,bytes32)`.
     * @dev Returns address of created contract even for fallback
     */
    fallback() external payable {
        require(msg.data.length > 0, "ERC2470: bad call");
        address payable createdContract = deploy(msg.data, bytes32(0));
        assembly {
            mstore(0, createdContract)
            return(0, 32)
        }
    }

    /**
     * @notice Deploys `_initCode` using `_salt` for defining the deterministic address.
     * @param _initCode Initialization code.
     * @param _salt Arbitrary value to modify resulting address.
     * @return createdContract Created contract address.
     */
    function deploy(bytes memory _initCode, bytes32 _salt)
        public
        payable
        returns (address payable createdContract)
    {
        assembly {
            createdContract := create2(callvalue(), add(_initCode, 0x20), mload(_initCode), _salt)
        }
        require(createdContract != address(0), "ERC2470: CREATE2 failed");
    }

    /**
     * @notice Calculates the resulting address of a contract created in this factory.
     * @param _initCode Initialization code.
     * @param _salt Arbitrary value to modify resulting address.
     * @return resultAddress predicted address.
     */
    function predictedAddress(
        bytes memory _initCode,
        bytes32 _salt
    ) 
        external 
        view 
        returns(address payable resultAddress) 
    {
        return address(uint256(keccak256(abi.encodePacked(
            byte(0xff),
            address(this),
            _salt,
            keccak256(_initCode)
        ))));
    }
}
// IV is a value changed to generate the vanity address.
// IV: TBD
```

### Deployment Transaction

Below is the raw transaction which MUST be used to deploy the smart contract on any chain.

```
TBD
```

The strings of `2470`'s at the end of the transaction are the `r` and `s` of the signature.
From this deterministic pattern (generated by a human), anyone can deduce that no one knows the private key for the deployment account.

### Deployment Method

This contract is going to be deployed using the keyless deployment method---also known as [Nick]'s method---which relies on a single-use address.
(See [Nick's article] for more details). This method works as follows:

1. Generate a transaction which deploys the contract from a new random account.
  - This transaction MUST NOT use [EIP-155] in order to work on any chain.
  - This transaction MUST have a relatively high gas price to be deployed on any chain. In this case, it is going to be 100 Gwei.

2. Forge a transaction with the following parameters:
    ```js
    {
        nonce: 0,
        gasPrice: 100000000000,
        value: 0,
        data: 'TBD',
        gasLimit: 270000,
        v: 27,
        r: '0x247000',
        s: '0x2470'
    }
    ```
    > The `r` and `s` values, made of starting `2470`, are obviously a human determined value, instead of a real signature.

3. We recover the sender of this transaction, i.e., the single-use deployment account.

    > Thus we obtain an account that can broadcast that transaction, but we also have the warranty that nobody knows the private key of that account.

4. Send exactly 0.027 ether to this single-use deployment account.

5. Broadcast the deployment transaction.

    > Note: 270000 is more gas than needed to deploy the smart contract, this ensures that future changes in OPCODE pricing are unlikely to cause this deploy transction to fail out of gas. A left over will sit in the address of about 0.001 ETH will be forever locked in the single use address. 

The resulting transaction hash is `TBD`.

This operation can be done on any chain, guaranteeing that the contract address is always the same and nobody can use that address with a different contract.


### Single-use Factory Deployment Account

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAB2UlEQVR4nO3dsU1DARBEQZdCDZRCG0jURg90QEA70ICzC1bLTvBi+9bzsy/58fr583vp7etbwa6/3wOA7gAYD4DxABgPgPEAGA+A8QAYD4DxABgPgPEAGA+A8QAYD4Dx4gA+Xt5PpQdIPwDX/QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgGYD2A67fPw0w/QABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADwPwGkf8Dr57eX3g8AALoPaC+9HwAAdB/QXno/AADoPqC99H4AANB9QHvp/QAAoPuA9tL7AQBA9wHtpfcDAIDuA9pL7wfAOoD0CxHpFzrSpfcDAIDuA9pL7wcAAN0HtJfeDwAAug9oL70fAAB0H9Beej8AAOg+oL30fgAA0H1Ae+n9AACg+4D20vsBAEB+BOUCYDwAxgNgPADGA2A8AMYDYDwAxgNgPADGA2A8AMYDYDwAxgNgvMf1hQR1B8B4AIwHwHgAjAfAeACMB8B4AIwHwHgAjAfAeACMB8B4AIwHwHhnANcXEtJ/uHDt+v2v+wEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAk/4AAAL56BraQkoAAAAASUVORK5CYII=)

`TBD`

This account is generated by reverse engineering it from its signature for the transaction. 
This way no one knows the private key, but it is known that it is the valid signer of the deployment transaction.

> To deploy the registry, 0.027 ether MUST be sent to this account *first*.

### Factory Contract Address
![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAB1klEQVR4nO3dsY3CABAEQEdUQml0hvSFUAsxISk08B+drNP+TrCx99YT28fr8v5Mcr3/jPJ83EaZPj+9//T9HQBk9wcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAnANqD0bO8PAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADA/wTQPsB2tvcHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgDNe4PYA29neDwAAsg9Iz/Z+AACQfUB6tvcDAIDsA9KzvR8AAGQfkJ7t/QAAIPuA9GzvBwAA2QekZ3s/AADIPiA92/sB0A5g+sOD7QOmz0/vP31/AIT3BwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD4A0D7gO39ASjvD0B5fwDK+wNQ3h+A8v4AlPcHoLw/AOX9ASjvD0B5fwDK+wNQ3h+A8v4AlPcHoLz/GMD2ANPnp/cHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgDMATDP9wME2gO0PbAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADAL/kCzPReJEuzwFwAAAAASUVORK5CYII=)

`TBD`

The contract has the address above for every chain on which it is deployed.
### ABI for ERC2470:
```json
[
        {
        "inputs": [
            {
                "internalType": "bytes",
                "name": "_initCode",
                "type": "bytes"
            },
            {
                "internalType": "bytes32",
                "name": "_salt",
                "type": "bytes32"
            }
        ],
        "name": "deploy",
        "outputs": [
            {
                "internalType": "address payable",
                "name": "createdContract",
                "type": "address"
            }
        ],
        "stateMutability": "payable",
        "type": "function"
    },
    {
        "stateMutability": "payable",
        "type": "fallback"
    }
]
```

## Rationale

ERC2470 allows user defined salt to facilitate the creation of vanity addresses for other projects. If vanity address is not necessary, salt `bytes(0)` should be used.
Contracts that are constructed by the ERC2470 MUST not use `msg.sender` in their constructor, all variables must came through initialization data. This is intentional, as if allowing a callback after creation to aid initialization state would lead to contracts with same address (but different chains) to have the same address but different initial state.
The resulting address can be calculated in chain by any contract using this formula: `address(keccak256(bytes1(0xff), 0xce0042B868300000d44A59004Da54A005ffdcf9f, _salt, keccak256(_code)) << 96)` or in javascript using https://github.com/ethereumjs/ethereumjs-util/blob/master/docs/README.md#const-generateaddress2.

## Backwards Compatibility

Does not apply as there are no past versions of Singleton Factory being used.

## Test Cases

TBD

## Implementation

https://github.com/3esmit/ERC2470

## Security Considerations

Some contracts can possibly not support being deployed on any chain, or require a different address per chain, that can be safely done by using comparison in [EIP-1344] in constructor.
Account contracts are singletons in the point of view of each user, when wallets want to signal what chain id is intended, [EIP-1191] should be used. 
Contracts deployed on factory must not use `msg.sender` in constructor, instead use constructor parameters, otherwise the factory would end up being the controller/only owner of those. 

## Copyright
Copyright and related rights waived via [CC0](https://creativecommons.org/publicdomain/zero/1.0/).

[EIP-155]: https://eips.ethereum.org/EIPS/eip-155
[EIP-1191]: https://eips.ethereum.org/EIPS/eip-1191
[EIP-1344]: https://eips.ethereum.org/EIPS/eip-1344
[EIP-1820]: https://eips.ethereum.org/EIPS/eip-1820
[EIP-2429]: https://gitlab.com/status-im/docs/EIPs/blob/secret-multisig-recovery/EIPS/eip-2429.md
[Nick's article]: https://medium.com/@weka/how-to-send-ether-to-11-440-people-187e332566b7
[Nick]: https://github.com/Arachnid/

